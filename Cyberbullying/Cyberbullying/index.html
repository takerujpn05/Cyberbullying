<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberbullying Conversation Simulation System</title>
    <!-- Tailwind CSS & Chart.js CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        #simulation-output {
            scroll-behavior: smooth;
        }
        #conversation-input {
            min-height: 150px;
        }
        .level-button {
            transition: background-color 0.2s, color 0.2s;
            background-color: #f3f4f6; /* gray-100 */
            color: #4b5563; /* gray-600 */
            border-color: #d1d5db; /* gray-300 */
        }
        .level-button:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        .level-button.active {
            background-color: #ef4444; /* red-500 */
            color: white;
            border-color: #dc2626; /* red-600 */
            font-weight: bold;
        }
        .auto-judged-word {
            background-color: #fef9c3; /* yellow-100 */
            border-radius: 3px;
        }
        .selected-range {
            border-radius: 3px;
        }
        .level-popover {
            position: absolute;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10;
            display: flex;
            padding: 4px;
            gap: 2px;
        }
        .delete-word-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }
        .delete-word-btn:hover {
            color: #ef4444;
        }
        .level-tooltip {
            position: absolute;
            background-color: #1f2937; /* gray-800 */
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 20;
            pointer-events: none; /* Tooltip should not be interactive */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-6xl">
        <header class="bg-white shadow-md rounded-lg p-4 mb-4 flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold text-gray-800" data-lang-key="title">Cyberbullying Conversation Simulation System</h1>
                <p class="text-gray-600 mt-1" data-lang-key="subtitle">Analyze the impact of aggressive remarks on communication delay by simulating a conversation log.</p>
            </div>
            <button id="lang-toggle-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg text-sm">日本語</button>
        </header>

        <main class="flex flex-col gap-6">
            <!-- Simulation Area -->
            <div class="w-full bg-white shadow-md rounded-lg flex flex-col p-6 gap-6">
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-lg font-bold text-gray-700" data-lang-key="inputHeader">1. Input Conversation Log</h2>
                        <button id="show-word-list-btn" class="text-sm font-medium text-blue-600 hover:underline" data-lang-key="manageList">
                            Manage Word List
                        </button>
                    </div>
                    <textarea id="conversation-input" class="w-full border border-gray-300 rounded-md p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" data-lang-key="inputPlaceholder" placeholder="Example:&#10;A: Did you do the homework?&#10;B: Annoying.&#10;C: Shut up."></textarea>
                    <button id="start-simulation-btn" class="mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm" data-lang-key="startSimulation">Start Simulation</button>
                </div>
                <div class="border-t border-gray-200 pt-4">
                     <h2 class="text-lg font-bold text-gray-700 mb-2" data-lang-key="resultsHeader">2. Simulation Results & Manual Intervention</h2>
                     <p class="text-xs text-gray-500 mb-2" data-lang-key="resultsSubtitle">You can set a level by selecting text with your mouse. Multiple ranges can be set. Press "Update Analysis" to reflect changes.</p>
                    <div id="simulation-output" class="flex-1 p-3 border rounded-md bg-gray-50 overflow-y-auto h-96">
                        <!-- Simulation results will be appended here -->
                    </div>
                </div>
            </div>

            <!-- Report Area -->
            <div class="w-full bg-white shadow-md rounded-lg p-6">
                <h2 class="text-xl font-bold text-gray-800 mb-2" data-lang-key="reportHeader">Experiment Report</h2>
                <button id="show-report-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg mb-4 text-sm" data-lang-key="updateAnalysis">Update Analysis</button>
                <div id="report-container" class="hidden space-y-8 pt-4 border-t border-gray-200">
                    <div>
                        <h3 class="text-md font-bold text-gray-700 mb-2 text-center" data-lang-key="timelineChartTitle">Conversation Timeline</h3>
                        <canvas id="timeline-chart"></canvas>
                    </div>
                    <div>
                        <h3 class="text-md font-bold text-gray-700 mb-2 text-center" data-lang-key="statementChartTitle">Delay Time per Statement</h3>
                        <canvas id="statement-delay-chart"></canvas>
                    </div>
                    <div>
                        <h3 class="text-md font-bold text-gray-700 mb-2 text-center" data-lang-key="subjectChartTitle">Total Delay Time by Subject</h3>
                        <canvas id="subject-delay-chart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Word List Modal -->
    <div id="word-list-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
        <div class="relative top-20 mx-auto p-5 border w-auto max-w-lg shadow-lg rounded-md bg-white">
            <div class="mt-3">
                <h3 class="text-lg leading-6 font-medium text-gray-900 text-center" data-lang-key="modalTitle">Manage Word List</h3>
                <div id="word-list-content" class="mt-4 px-2 py-3 max-h-80 overflow-y-auto">
                    <!-- Word list will be populated here by JS -->
                </div>
                <!-- Add new word form -->
                <div class="mt-4 px-4 py-3 border-t">
                     <h4 class="text-md font-semibold text-gray-800 mb-2" data-lang-key="addNewWord">Add New Word</h4>
                     <div class="flex items-center gap-2">
                         <input type="text" id="new-word-input" class="w-full border border-gray-300 rounded-md p-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" data-lang-key="newWordPlaceholder" placeholder="Enter word...">
                         <div id="new-word-level-selector" class="flex-shrink-0 flex items-center gap-1">
                            <!-- Level buttons will be inserted by JS -->
                         </div>
                         <button id="add-word-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm" data-lang-key="addBtn">Add</button>
                     </div>
                </div>
                <div class="items-center px-4 py-3 border-t mt-2">
                    <button id="close-modal-btn" class="px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-300" data-lang-key="closeBtn">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- Translations ---
        const translations = {
            en: {
                title: "Cyberbullying Conversation Simulation System",
                subtitle: "Analyze the impact of aggressive remarks on communication delay by simulating a conversation log.",
                inputHeader: "1. Input Conversation Log",
                manageList: "Manage Word List",
                inputPlaceholder: "Example:\nA: Did you do the homework?\nB: Annoying.\nC: Shut up.",
                startSimulation: "Start Simulation",
                resultsHeader: "2. Simulation Results & Manual Intervention",
                resultsSubtitle: 'You can set a level by selecting text with your mouse. Multiple ranges can be set. Press "Update Analysis" to reflect changes.',
                reportHeader: "Experiment Report",
                updateAnalysis: "Update Analysis",
                timelineChartTitle: "Conversation Timeline",
                statementChartTitle: "Delay Time per Statement",
                subjectChartTitle: "Total Delay Time by Subject",
                modalTitle: "Manage Word List",
                addNewWord: "Add New Word",
                newWordPlaceholder: "Enter word...",
                addBtn: "Add",
                closeBtn: "Close",
                levelLabel: "Level",
                delayUnit: "s delay",
                noDelay: "No delay",
                noData: "No data to analyze. Please start a simulation first.",
                wordExists: 'The word "{word}" already exists in the list.',
                enterWord: 'Please enter a word.',
                subject: "Subject",
                statementNumber: "Statement Number",
                elapsedTime: "Elapsed Time (s)",
                idealTime: "Ideal Time (No Delay) (s)",
                delayTime: "Delay Time (s)",
                totalDelayTime: "Total Delay Time (s)",
                unknownSpeaker: "Unknown"
            },
            ja: {
                title: "サイバーブリング会話シミュレーションシステム",
                subtitle: "会話ログを貼り付け、攻撃的発言によるコミュニケーション遅延への影響を分析します。",
                inputHeader: "1. 会話ログの入力",
                manageList: "判定単語リストを管理",
                inputPlaceholder: "例：\nA: 宿題やった？\nB: うざい\nC: 黙れ",
                startSimulation: "シミュレーションを開始",
                resultsHeader: "2. シミュレーション結果と手動介入",
                resultsSubtitle: "テキストをドラッグで選択してレベルを設定できます。複数の範囲に設定可能です。「分析結果を更新」を押して分析してください。",
                reportHeader: "実験結果レポート",
                updateAnalysis: "分析結果を更新",
                timelineChartTitle: "会話タイムライン",
                statementChartTitle: "各発言の遅延時間",
                subjectChartTitle: "被験者別の総遅延時間",
                modalTitle: "判定単語リストの管理",
                addNewWord: "新しい単語を追加",
                newWordPlaceholder: "単語を入力...",
                addBtn: "追加",
                closeBtn: "閉じる",
                levelLabel: "レベル",
                delayUnit: "秒の遅延",
                noDelay: "遅延なし",
                noData: "データがありません。先にシミュレーションを開始してください。",
                wordExists: '単語「{word}」は既にリストに存在します。',
                enterWord: '単語を入力してください。',
                subject: "被験者",
                statementNumber: "発言番号",
                elapsedTime: "実際の経過時間（秒）",
                idealTime: "遅延なしの場合（秒）",
                delayTime: "遅延時間（秒）",
                totalDelayTime: "総遅延時間（秒）",
                unknownSpeaker: "不明"
            }
        };

        // --- Settings ---
        const defaultBullyingWords_en = {
            "stupid": { level: 1 }, "dumb": { level: 1 }, "loser": { level: 1 }, "idiot": { level: 1 }, "weirdo": { level: 1 },
            "lame": { level: 2 }, "pathetic": { level: 2 }, "worthless": { level: 2 }, "freak": { level: 2 }, "annoying": { level: 2 },
            "moron": { level: 3 }, "loser nobody": { level: 3 }, "you don’t belong here": { level: 3 }, "get lost": { level: 3 }, "shut up": { level: 3 },
            "retard": { level: 4 }, "freaking useless": { level: 4 }, "piece of trash": { level: 4 }, "disgusting": { level: 4 }, "kill yourself": { level: 4 },
            "die": { level: 5 }, "burn in hell": { level: 5 }, "I’ll kill you": { level: 5 }, "you’re nothing": { level: 5 }, "go kill yourself": { level: 5 }
        };
        const defaultBullyingWords_ja = {
            "バカ": { level: 1 }, "アホ": { level: 1 }, "ダサい": { level: 1 }, "うざい": { level: 1 }, "のろま": { level: 1 }, "へたくそ": { level: 1 }, "まぬけ": { level: 1 }, "トロい": { level: 1 }, "しつこい": { level: 1 }, "だめ": { level: 1 },
            "キモい": { level: 2 }, "消えろ": { level: 2 }, "雑魚": { level: 2 }, "にせもの": { level: 2 }, "くだらない": { level: 2 }, "頭悪い": { level: 2 }, "価値ない": { level: 2 }, "使えない": { level: 2 }, "弱虫": { level: 2 }, "ごみ": { level: 2 },
            "デブ": { level: 3 }, "ブス": { level: 3 }, "死ね": { level: 3 }, "障害者": { level: 3 }, "クズ": { level: 3 }, "負け犬": { level: 3 }, "ブタ": { level: 3 }, "無能": { level: 3 }, "人間のくず": { level: 3 }, "最低": { level: 3 }, "黙れ": { level: 3 },
            "殺す": { level: 4 }, "殴る": { level: 4 }, "地獄に落ちろ": { level: 4 }, "呪う": { level: 4 }, "蹴り飛ばす": { level: 4 }, "消えてなくなれ": { level: 4 }, "ぶち殺す": { level: 4 }, "死んじまえ": { level: 4 }, "首を絞める": { level: 4 }, "潰す": { level: 4 },
            "お前を殺す": { level: 5 }, "家に火をつける": { level: 5 }, "刺す": { level: 5 }, "レイプする": { level: 5 }, "殺してやる": { level: 5 }, "家族を殺す": { level: 5 }, "追い込む": { level: 5 }, "ぶっ壊す": { level: 5 }, "刺し殺す": { level: 5 }, "焼き殺す": { level: 5 }
        };
        let defaultBullyingWords = {};
        let bullyingWords = {}; // This will be the live, merged list

        const manualDelayLevels = {
            0: 0, 1: 5000, 2: 10000, 3: 15000, 4: 20000, 5: 25000
        };

        const BASE_REPLY_DELAY = 1000;

        // --- DOM Elements ---
        const langToggleBtn = document.getElementById('lang-toggle-btn');
        const allTranslatableElements = document.querySelectorAll('[data-lang-key]');
        const conversationInput = document.getElementById('conversation-input');
        const startSimulationBtn = document.getElementById('start-simulation-btn');
        const simulationOutput = document.getElementById('simulation-output');
        const showReportBtn = document.getElementById('show-report-btn');
        const reportContainer = document.getElementById('report-container');
        const timelineChartCanvas = document.getElementById('timeline-chart');
        const subjectDelayChartCanvas = document.getElementById('subject-delay-chart');
        const statementDelayChartCanvas = document.getElementById('statement-delay-chart');
        const showWordListBtn = document.getElementById('show-word-list-btn');
        const wordListModal = document.getElementById('word-list-modal');
        const wordListContent = document.getElementById('word-list-content');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const newWordInput = document.getElementById('new-word-input');
        const newWordLevelSelector = document.getElementById('new-word-level-selector');
        const addWordBtn = document.getElementById('add-word-btn');

        // --- System Variables ---
        let currentLang = 'en';
        let lineChartInstance = null;
        let barChartInstance = null;
        let statementDelayChartInstance = null;

        // --- Language Functions ---
        function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('language', lang);
            defaultBullyingWords = lang === 'ja' ? defaultBullyingWords_ja : defaultBullyingWords_en;

            allTranslatableElements.forEach(el => {
                const key = el.dataset.langKey;
                const translation = translations[lang][key];
                if(el.placeholder) {
                    el.placeholder = translation;
                } else {
                    el.textContent = translation;
                }
            });

            langToggleBtn.textContent = lang === 'en' ? '日本語' : 'English';
            loadWords();
        }

        // --- Word Persistence Functions ---
        function loadWords() {
            const customWords = JSON.parse(localStorage.getItem(`customBullyingWords_${currentLang}`)) || {};
            bullyingWords = { ...defaultBullyingWords, ...customWords };
        }

        function updateWordLevel(word, level) {
            const customWords = JSON.parse(localStorage.getItem(`customBullyingWords_${currentLang}`)) || {};
            if (defaultBullyingWords.hasOwnProperty(word) && defaultBullyingWords[word].level === level) {
                delete customWords[word];
            } else {
                customWords[word] = { level };
            }
            localStorage.setItem(`customBullyingWords_${currentLang}`, JSON.stringify(customWords));
            loadWords();
        }

        function deleteCustomWord(word) {
            const customWords = JSON.parse(localStorage.getItem(`customBullyingWords_${currentLang}`)) || {};
            delete customWords[word];
            localStorage.setItem(`customBullyingWords_${currentLang}`, JSON.stringify(customWords));
            loadWords();
        }

        // --- Event Listeners ---
        langToggleBtn.addEventListener('click', () => setLanguage(currentLang === 'en' ? 'ja' : 'en'));
        startSimulationBtn.addEventListener('click', runSimulation);
        showReportBtn.addEventListener('click', generateReport);
        showWordListBtn.addEventListener('click', showWordList);
        closeModalBtn.addEventListener('click', hideWordList);
        addWordBtn.addEventListener('click', addNewWord);
        wordListModal.addEventListener('click', (e) => {
            if (e.target === wordListModal) { hideWordList(); }
        });

        document.addEventListener('click', (e) => {
            const popover = document.querySelector('.level-popover');
            if (popover && !popover.contains(e.target) && !e.target.closest('.message-text')) {
                popover.remove();
            }
        });

        simulationOutput.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            if (selection.isCollapsed || selectedText === '') return;
            const messageTextElement = selection.getRangeAt(0).commonAncestorContainer.parentElement.closest('.message-text');
            if (messageTextElement) {
                 createLevelPopover(selection.getRangeAt(0), selectedText);
            }
        });

        simulationOutput.addEventListener('mouseover', (e) => {
            if (e.target.matches('[data-level]')) {
                const span = e.target;
                const level = span.dataset.level;
                if (level) createCustomTooltip(span, `${translations[currentLang].levelLabel} ${level}`);
            }
        });
        simulationOutput.addEventListener('mouseout', (e) => {
            if (e.target.matches('[data-level]')) removeCustomTooltip();
        });

        // --- Core Functions ---

        function createCustomTooltip(targetElement, text) {
            removeCustomTooltip();
            const tooltip = document.createElement('div');
            tooltip.className = 'level-tooltip';
            tooltip.textContent = text;
            document.body.appendChild(tooltip);
            const rect = targetElement.getBoundingClientRect();
            tooltip.style.top = `${window.scrollY + rect.top - tooltip.offsetHeight - 5}px`;
            tooltip.style.left = `${window.scrollX + rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2)}px`;
        }

        function removeCustomTooltip() {
            const tooltip = document.querySelector('.level-tooltip');
            if (tooltip) tooltip.remove();
        }

        function createLevelPopover(range, selectedText) {
            removeCustomTooltip();
            const existingPopover = document.querySelector('.level-popover');
            if (existingPopover) { existingPopover.remove(); }

            const popover = document.createElement('div');
            popover.className = 'level-popover';

            for (let i = 0; i <= 5; i++) {
                const button = document.createElement('button');
                button.className = 'level-button w-7 h-7 rounded text-xs border';
                button.textContent = i;
                button.dataset.level = i;

                button.onclick = () => {
                    const wrapper = (range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ? range.commonAncestorContainer : range.commonAncestorContainer.parentElement).closest('.message-wrapper');

                    if (wrapper && !wrapper.dataset.manualOverride) {
                        wrapper.dataset.manualOverride = 'true';
                    }

                    const fragment = range.extractContents();
                    const existingSpans = fragment.querySelectorAll('.selected-range, .auto-judged-word');
                    existingSpans.forEach(span => span.replaceWith(...span.childNodes));
                    document.normalize();

                    if (i > 0) {
                        const newSpan = document.createElement('span');
                        newSpan.className = 'selected-range';
                        newSpan.dataset.level = i;
                        newSpan.style.backgroundColor = `rgba(239, 68, 68, ${0.1 + i*0.1})`;
                        newSpan.appendChild(fragment);
                        range.insertNode(newSpan);

                        if (!bullyingWords.hasOwnProperty(selectedText)) {
                             updateWordLevel(selectedText, i);
                        }
                    } else {
                        range.insertNode(fragment);
                    }

                    popover.remove();
                    window.getSelection().removeAllRanges();
                };
                popover.appendChild(button);
            }

            document.body.appendChild(popover);
            const rect = range.getBoundingClientRect();
            popover.style.top = `${window.scrollY + rect.top - popover.offsetHeight - 5}px`;
            popover.style.left = `${window.scrollX + rect.left + (rect.width / 2) - (popover.offsetWidth / 2)}px`;
        }


        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function runSimulation() {
            simulationOutput.innerHTML = '';
            reportContainer.classList.add('hidden');
            if (lineChartInstance) { lineChartInstance.destroy(); }
            if (barChartInstance) { barChartInstance.destroy(); }
            if (statementDelayChartInstance) { statementDelayChartInstance.destroy(); }

            const lines = conversationInput.value.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return;

            lines.forEach((line, index) => appendMessage(line, index));
            generateReport();
        }

        function parseLine(line) {
            const parts = line.split(/:(.*)/s);
            if (parts.length > 1) {
                return { speaker: parts[0].trim(), message: parts[1].trim() };
            }
            return { speaker: translations[currentLang].unknownSpeaker, message: line.trim() };
        }

        function analyzeMessage(text) {
            let totalDelay = 0;
            const sortedWords = Object.keys(bullyingWords).sort((a, b) => b.length - a.length);
            let processedText = text;
            for (const word of sortedWords) {
                const regex = new RegExp(word, 'gi');
                if (processedText.match(regex)) {
                    const level = bullyingWords[word.toLowerCase()].level;
                    totalDelay += manualDelayLevels[level] || 0;
                    processedText = processedText.replace(regex, '');
                }
            }
            return { totalDelay };
        }

        function appendMessage(line, index) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper mb-2 p-2 rounded-md';
            wrapper.dataset.line = line;

            const messageContent = document.createElement('div');
            messageContent.className = 'flex-grow';

            let escapedLine = line.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

            const sortedWords = Object.keys(bullyingWords).sort((a, b) => b.length - a.length);
            if (sortedWords.length > 0) {
                 const regex = new RegExp(`(${sortedWords.join('|')})`, 'gi');
                 escapedLine = escapedLine.replace(regex, (match, word) => {
                     const level = bullyingWords[word.toLowerCase()].level;
                     const opacity = 0.3 + level * 0.1;
                     return `<span class="auto-judged-word" data-level="${level}" style="background-color: rgba(250, 204, 21, ${opacity})">${match}</span>`;
                 });
            }

            messageContent.innerHTML = `<p class="text-sm flex items-center"><span class="timestamp font-bold text-blue-600 mr-2">[--:--]</span><span class="delay-display text-red-500 font-bold text-xs mr-2 w-16 text-right"></span><span class="message-text">${escapedLine}</span></p>`;

            wrapper.appendChild(messageContent);
            simulationOutput.appendChild(wrapper);
        }

        function generateReport() {
            const messageWrappers = document.querySelectorAll('#simulation-output .message-wrapper');
            if (messageWrappers.length === 0) {
                 const reportMsg = document.createElement('p');
                 reportMsg.textContent = translations[currentLang].noData;
                 reportMsg.className = 'text-red-500 text-sm text-center error-message';
                 if (!reportContainer.querySelector('.error-message')) {
                    reportContainer.prepend(reportMsg);
                    setTimeout(() => reportMsg.remove(), 3000);
                 }
                return;
            }

            let currentTime = 0;
            const timelineData = [];
            const delayBySubject = { 'A': 0, 'B': 0, 'C': 0 };
            const statementDelays = [];

            messageWrappers.forEach((wrapper, index) => {
                let bullyingDelay = 0;

                if (wrapper.dataset.manualOverride === 'true') {
                    const selectedRanges = wrapper.querySelectorAll('.selected-range');
                    selectedRanges.forEach(span => {
                        const level = parseInt(span.dataset.level, 10);
                        bullyingDelay += manualDelayLevels[level] || 0;
                    });
                } else {
                     const { message } = parseLine(wrapper.dataset.line);
                     bullyingDelay = analyzeMessage(message).totalDelay;
                }

                statementDelays.push(bullyingDelay / 1000);

                const { speaker } = parseLine(wrapper.dataset.line);
                if (bullyingDelay > 0 && delayBySubject.hasOwnProperty(speaker)) {
                    delayBySubject[speaker] += bullyingDelay;
                }

                if (index > 0) {
                    currentTime += BASE_REPLY_DELAY;
                }

                const displayTime = currentTime;
                timelineData.push(displayTime);

                const timestampEl = wrapper.querySelector('.timestamp');
                timestampEl.textContent = `[${formatTime(displayTime)}]`;

                const delayDisplayEl = wrapper.querySelector('.delay-display');
                if (bullyingDelay > 0) {
                    delayDisplayEl.textContent = `+${(bullyingDelay / 1000).toFixed(0)}s`;
                } else {
                    delayDisplayEl.textContent = '';
                }

                currentTime += bullyingDelay;
            });

            reportContainer.classList.remove('hidden');

            if (lineChartInstance) { lineChartInstance.destroy(); }
            if (barChartInstance) { barChartInstance.destroy(); }
            if (statementDelayChartInstance) { statementDelayChartInstance.destroy(); }

            const lineLabels = timelineData.map((_, index) => `${translations[currentLang].statementNumber.split(' ')[0]}. ${index + 1}`);
            const lineData = timelineData.map(time => time / 1000);
            const noDelayLineData = lineLabels.map((_, index) => (index * BASE_REPLY_DELAY) / 1000);

            lineChartInstance = new Chart(timelineChartCanvas, {
                type: 'line',
                data: {
                    labels: lineLabels,
                    datasets: [
                        { label: translations[currentLang].elapsedTime, data: lineData, borderColor: 'rgba(59, 130, 246, 1)', backgroundColor: 'rgba(59, 130, 246, 0.2)', fill: true, tension: 0.1 },
                        { label: translations[currentLang].idealTime, data: noDelayLineData, borderColor: 'rgba(107, 114, 128, 1)', backgroundColor: 'rgba(107, 114, 128, 0.1)', fill: false, tension: 0.1, borderDash: [5, 5] }
                    ]
                },
                options: {
                    scales: { y: { beginAtZero: true, title: { display: true, text: translations[currentLang].elapsedTime } }, x: { title: { display: true, text: translations[currentLang].statementNumber } } },
                    responsive: true,
                    plugins: { legend: { display: true, position: 'top' } }
                }
            });

            statementDelayChartInstance = new Chart(statementDelayChartCanvas, {
                type: 'line',
                data: {
                    labels: lineLabels,
                    datasets: [{
                        label: translations[currentLang].delayTime,
                        data: statementDelays,
                        borderColor: 'rgba(234, 179, 8, 1)',
                        backgroundColor: 'rgba(234, 179, 8, 0.2)',
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: translations[currentLang].delayTime } },
                        x: { title: { display: true, text: translations[currentLang].statementNumber } }
                    },
                    responsive: true,
                    plugins: { legend: { display: false } }
                }
            });

            const subjectLabels = Object.keys(delayBySubject);
            const subjectData = Object.values(delayBySubject).map(d => d / 1000);

            barChartInstance = new Chart(subjectDelayChartCanvas, {
                type: 'bar',
                data: {
                    labels: subjectLabels,
                    datasets: [{
                        label: translations[currentLang].totalDelayTime,
                        data: subjectData,
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: { y: { beginAtZero: true, title: { display: true, text: translations[currentLang].totalDelayTime } }, x: { title: { display: true, text: translations[currentLang].subject } } },
                    responsive: true,
                    plugins: { legend: { display: false } }
                }
            });
        }

        function handleWordEdit(e) {
            if (e.key === 'Escape') {
                e.target.textContent = e.target.dataset.originalWord;
                e.target.blur();
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter' || e.type === 'blur') {
                e.preventDefault();
                const span = e.target;
                const originalWord = span.dataset.originalWord;
                const newWord = span.textContent.trim();
                span.removeEventListener('blur', handleWordEdit);
                if (!newWord || newWord === originalWord) {
                    span.textContent = originalWord;
                    if (e.type === 'keydown') span.blur();
                    return;
                }
                if (bullyingWords.hasOwnProperty(newWord) && newWord !== originalWord) {
                    alert(translations[currentLang].wordExists.replace('{word}', newWord));
                    span.textContent = originalWord;
                    if (e.type === 'keydown') span.blur();
                    return;
                }
                const level = bullyingWords[originalWord].level;
                const customWords = JSON.parse(localStorage.getItem(`customBullyingWords_${currentLang}`)) || {};
                delete customWords[originalWord];
                localStorage.setItem(`customBullyingWords_${currentLang}`, JSON.stringify(customWords));
                loadWords();
                updateWordLevel(newWord, level);
                showWordList();
            }
        }

        function showWordList() {
            wordListContent.innerHTML = '';
            const allWords = { ...bullyingWords };
            const wordsByLevel = {};
            for (const word in allWords) {
                const level = allWords[word].level;
                if (!wordsByLevel[level]) {
                    wordsByLevel[level] = [];
                }
                wordsByLevel[level].push(word);
            }

            const sortedLevels = Object.keys(wordsByLevel).sort((a, b) => a - b);

            for (const level of sortedLevels) {
                const sectionWrapper = document.createElement('div');
                sectionWrapper.className = 'mb-4';
                const levelTitle = document.createElement('h4');
                levelTitle.className = 'text-md font-semibold text-gray-800 bg-gray-100 p-2 rounded';
                const delayInSeconds = manualDelayLevels[level] / 1000;
                const delayText = delayInSeconds > 0 ? `${delayInSeconds}${translations[currentLang].delayUnit}` : translations[currentLang].noDelay;
                levelTitle.textContent = `${translations[currentLang].levelLabel} ${level} (${delayText})`;
                sectionWrapper.appendChild(levelTitle);

                const wordContainer = document.createElement('div');
                wordsByLevel[level].sort().forEach(word => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'flex justify-between items-center p-2 border-b border-gray-200';
                    const isDefault = defaultBullyingWords.hasOwnProperty(word) && defaultBullyingWords[word].level === allWords[word].level;
                    const isCustom = !defaultBullyingWords.hasOwnProperty(word);
                    const isOverridden = defaultBullyingWords.hasOwnProperty(word) && !isDefault;
                    let bgColor = isDefault ? 'bg-gray-200 text-gray-800' : 'bg-blue-100 text-blue-800';
                    if (isOverridden) bgColor = 'bg-yellow-100 text-yellow-800';
                    const wordTag = document.createElement('span');
                    wordTag.className = `text-sm font-medium px-2.5 py-0.5 rounded ${bgColor}`;
                    wordTag.textContent = word;
                    if(isCustom || isOverridden) {
                        wordTag.contentEditable = true;
                        wordTag.dataset.originalWord = word;
                        wordTag.addEventListener('keydown', handleWordEdit);
                        wordTag.addEventListener('blur', handleWordEdit);
                        wordTag.title = 'Click to edit';
                        wordTag.style.cursor = 'text';
                        wordTag.style.outline = 'none';
                    }
                    entryDiv.appendChild(wordTag);
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'flex items-center gap-1';
                    for (let i = 0; i <= 5; i++) {
                        const button = document.createElement('button');
                        button.className = `level-button w-6 h-6 rounded text-xs border ${allWords[word].level === i ? 'active' : ''}`;
                        button.dataset.level = i;
                        button.textContent = i;
                        button.onclick = () => {
                            updateWordLevel(word, i);
                            showWordList();
                        };
                        controlsDiv.appendChild(button);
                    }
                    if (isCustom) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-word-btn ml-2';
                        deleteBtn.innerHTML = '&#x2715;';
                        deleteBtn.onclick = () => {
                            deleteCustomWord(word);
                            showWordList();
                        };
                        controlsDiv.appendChild(deleteBtn);
                    }
                    entryDiv.appendChild(controlsDiv);
                    wordContainer.appendChild(entryDiv);
                });
                sectionWrapper.appendChild(wordContainer);
                wordListContent.appendChild(sectionWrapper);
            }
            wordListModal.classList.remove('hidden');
        }

        function hideWordList() {
            wordListModal.classList.add('hidden');
        }

        function addNewWord() {
            const newWord = newWordInput.value.trim();
            if (!newWord) {
                alert(translations[currentLang].enterWord);
                return;
            }
            if (bullyingWords.hasOwnProperty(newWord)) {
                alert(translations[currentLang].wordExists.replace('{word}', newWord));
                return;
            }
            const selectedLevelButton = newWordLevelSelector.querySelector('.active');
            const level = selectedLevelButton ? parseInt(selectedLevelButton.dataset.level) : 0;
            updateWordLevel(newWord, level);
            newWordInput.value = '';
            showWordList();
        }

        function populateNewWordLevelSelector() {
            newWordLevelSelector.innerHTML = '';
            for (let i = 0; i <= 5; i++) {
                const button = document.createElement('button');
                button.className = 'level-button w-6 h-6 rounded text-xs border';
                button.textContent = i;
                button.dataset.level = i;
                if (i === 0) {
                    button.classList.add('active');
                }
                button.onclick = () => {
                    Array.from(newWordLevelSelector.children).forEach(child => child.classList.remove('active'));
                    button.classList.add('active');
                };
                newWordLevelSelector.appendChild(button);
            }
        }

        // Initial setup
        const savedLang = localStorage.getItem('language') || 'ja'; // Default to Japanese
        setLanguage(savedLang);
        populateNewWordLevelSelector();
    </script>
</body>
</html>

